/**
 * Core Philosophy:
 * This ruleset has a hybrid security model. User profiles are strictly private,
 * enforcing an ownership model where users can only access their own data tree
 * under `/users/{userId}`. In contrast, incident data is stored in a top-level
 * `/incidents` collection which is publicly readable to allow all users to view
 * alerts, but write access is restricted to authenticated users.
 *
 * Data Structure:
 * - /users/{userId}: A user's private profile document.
 * - /incidents/{incidentId}: A publicly-readable incident document.
 * - /incidents/{incidentId}/verifications/{verificationId}: Publicly-readable
 *   verifications for an incident.
 *
 * Key Security Decisions:
 * - Public Incident Data: The `/incidents` collection is readable by anyone to
 *   facilitate the core "nearby alerts" feature.
 * - Authenticated Writes: Only signed-in users can create incidents and verifications.
 * - Ownership for Modification: Users can only update or delete the incidents
 *   and verifications that they themselves created, enforced by checking
 *   `resource.data.userId`.
 * - Relational Integrity: On creation, documents must contain ID fields that
 *   match their context (e.g., an incident's `userId` must match the creator's
 *   UID). These relational fields are then enforced as immutable.
 * - Prototyping Flexibility: While authorization and relational links are
 *   strictly enforced, the rules do not validate the shape or data types of
 *   other document fields, allowing for rapid front-end development.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isCreatingValidUserProfile(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    function isUserProfileImmutable() {
      return request.resource.data.id == resource.data.id;
    }
    
    // Checks that the user creating the document is the user referenced in the document
    function isResourceCreator() {
      return request.auth.uid == request.resource.data.userId;
    }
    
    // Checks that the owner of an existing document is the one making the request
    function isResourceOwner() {
        return request.auth.uid == resource.data.userId;
    }

    function isIncidentImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    function isCreatingValidVerification(incidentId) {
      return request.resource.data.userId == request.auth.uid && request.resource.data.incidentId == incidentId;
    }

    function isVerificationImmutable() {
      return request.resource.data.userId == resource.data.userId
          && request.resource.data.incidentId == resource.data.incidentId;
    }

    // --------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------

    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingValidUserProfile(userId);
      allow update: if isExistingOwner(userId) && isUserProfileImmutable();
      allow delete: if isExistingOwner(userId);
    }
    
    match /incidents/{incidentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isResourceCreator();
      allow update: if isSignedIn() && isResourceOwner() && isIncidentImmutable();
      allow delete: if isSignedIn() && isResourceOwner();
    }

    match /incidents/{incidentId}/verifications/{verificationId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isCreatingValidVerification(incidentId);
      allow update: if isSignedIn() && isResourceOwner() && isVerificationImmutable();
      allow delete: if isSignedIn() && isResourceOwner();
    }
  }
}
